<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimal-ui">
    <title><%= title %></title>
    <link rel='stylesheet' href='/stylesheets/jquery.textcomplete.css'/>
    <link rel="stylesheet" href="/stylesheets/side-menu.css">
    <link rel="stylesheet" href="/stylesheets/jquery-ui.min.css">
    <link rel='stylesheet' href='/stylesheets/style.css'/>
    <link rel='stylesheet' href='/stylesheets/jquery.taghandler.css'/>
    <link rel='stylesheet' href='/stylesheets/jquery.content-panel-switcher.css'/>
    <script src="/javascripts/jquery.content-panel-switcher.js"></script>
    <link rel="stylesheet" type="text/css" href="/stylesheets/tooltipster.css"/>
    <link rel="stylesheet" type="text/css" href="/stylesheets/tooltipster-noir.css"/>


</head>
<body>
<% include statsabove %>
<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
    <div id="menu">
        <div class="pure-menu pure-menu-open">
            <% if (locals.user || perceivername) { %>
            <% if (perceivername) { %>
            <a class="pure-menu-heading" href="/<%= perceivername %>"><%= perceivername %></a>
            <% } else { %>
            <a class="pure-menu-heading" href="/<%= user.name %>/edit"><%= user.name %></a>
            <% } %>
            <br>
            <ul id="contexts" class="contexts">

            </ul>
            &nbsp;<br><br>

            <% } else { %>
            <% include menu %>

            <% } %>
        </div>
    </div>
    <div id='content'>
        <div id='statements'>

            <div id="entries">

                <% entries.forEach(function(entry) { %>
                <div class='entry' data-uid='<%= entry.uid %>' data-timestamp='<%= entry.timestamp %>'
                     data-hashtags='<%= entry.name %>'>
                    <p class='entry-text'><%- entry.text %></p>
                    <p class='entry-date'><%= entry.timestamp %></p>
                    <p class='entry-menu'>&nbsp;&nbsp;&nbsp;<a class="app-link-menu" href="#">show filtered</a></p>
                    <div class='separator'>&nbsp;</div>
                    <div id='<%= entry.uid %>' class='hidden'></div>
                </div>
                <% }) %>

                <% include messages %>
                <div id="warnings"></div>
                <div id="messages"></div>
            </div>


            <div id="entryform">

                <% if (!perceivername) { %>

                <div id='switcher-selector' class='pure-menu pure-menu-open pure-menu-horizontal'
                     style="background: none;">
                    <ul id="topmenuitems">

                        <li>
                            <a id="finds" class="switcher set1">find</a>
                        </li>
                        <li class="pure-menu-selected-top">
                            <a id="adds" class="switcher set1">add</a>
                        </li>
                        <li>
                            <a id="imports" href="/import?context=<%= context %>">import</a>
                        </li>


                    </ul>

                    <br>&nbsp;<br>

                </div>

                <% } %>

                <a href="javascript:" id="graph-link">
                    <span></span>
                </a>
                <a href="javascript:" id="windowdown-link">
                    <span></span>
                </a>
                <% if (!perceivername) { %>
                <a href="javascript:" id="collaborate-link">
                    <!-- Collaborate icon -->
                    <span></span>
                </a>
                <% } %>

                <% if (contextpublic && context && !perceivername && entries.length > 0) { %>
                <a href="javascript:" id="privacy-link" class="is-public">
                    <!-- Share icon -->
                    <span></span>
                </a>
                <% } else if (!perceivername && context && entries.length > 0) { %>
                <a href="javascript:" id="privacy-link">
                    <!-- Share icon -->
                    <span></span>
                </a>
                <% } %>

                <% if ((context && entries.length > 2) && (!perceivername)) { %>
                <form action='/post' name='deletecontext' id="deletecontext" method='post' class='pure-form'
                      onsubmit="return confirm('Deleting the context will delete all the statements inside. Are you sure?');">

                    <input type="hidden" name="context" value="<%= context %>">
                    <input type="hidden" id="selectedContexts" name="selectedContexts" value="">
                    <input type="hidden" name="statementid" value="">
                    &nbsp;<br>
                    <input type='submit' id="deletecontextbutton" name="delete" value="delete context">

                </form>
                <% } %>

                <!-- the panel to show content -->

                <div id="switcher-panel"></div>

                <!-- form to add, later do import here -->
                <% if (!perceivername) { %>
                <div id="adds-content" class="switcher-content set1 show">
                    <% } else { %>
                    <div id="adds-content" class="switcher-content set1">
                        <% } %>
                        <form action='/post' name='submitform' id="submitform" method='post' class='pure-form'>

                            <textarea columns="40" rows="4" name='entry[body]' id="statement"
                                      placeholder='type in some words or #hashtags to see how they connect'>
                                <% if (url) { %>
                                <%= urltitle %> <%= url %>
                                <% } %>
                            </textarea>
                            <div id="addToContextsLabel">sets:</div>
                            <ul id="addToContexts"></ul>
                            <input type="hidden" id="addedContexts" name="addedContexts">
                            <input type="hidden" id="context" name="context" value="<%= context %>">
                            <input type="hidden" id="selectedContexts" name="selectedContexts" value="">
                            <input type="hidden" id="statementid" name="statementid" value="">
                            <input type="hidden" name="timestamp" value="">
                            &nbsp;<br>
                            <input type='submit' id="submitbutton" name="btnSubmit" value="save"
                                   class="pure-button pure-button-primary">

                        </form>

                    </div>


                    <!-- form to find -->
                    <% if (perceivername) { %>
                    <div id="finds-content" class="switcher-content set1 show">
                        <% } else { %>
                        <div id="finds-content" class="switcher-content set1">
                            <% } %>
                            <form class="pure-form" id="searchform">
                                <input type="text" id="search" size="14" maxlength="20" class="pure-input"
                                       placeholder="search...">
                                &nbsp;&nbsp;
                                <input type='submit' name="submit" value=">" class="pure-button pure-button-primary">
                            </form>
                        </div>
                    </div>
                </div>

                <div id="graph-container"></div>


                <a href="javascript:" id="chat-link" title="show / hide the text">
                    <!-- Chat icon -->
                    <span></span>
                </a>
                <div id="controls">
                    <div id="graph-reload">
                        <a href="javascript:" id="go_next"><img src="/images/eyezoom.png"
                                                                title="choose a few nodes from the graph and click this button to find out more"
                                                                vspace="0" border="0"></a><br><a
                                href="javascript:location.reload();"><img src="/images/reload.png"
                                                                          title="clear and reload graph" vspace="6"
                                                                          border="0"></a><br><a href="javascript:"
                                                                                                id="improve-layout"><img
                                    src="/images/diamond.png" title="improve graph layout" vspace="3" border="0"></a>

                    </div>

                    <div id="graph-tools">
                        <a href="javascript:" id="zoom-in"><img src="/images/zoom-in.png" border="0"></a><br><a
                                href="javascript:" id="zoom-out"><img src="/images/zoom-out.png" border="0"></a>
                    </div>
                    <% if (!perceivername) { %>
                    <a href="javascript:" id="microphone-link" class="tooltip" title="voice to text on/off">
                        <!-- Microphone icon -->
                        <span></span>
                    </a>
                    <% } %>
                </div>

            </div>


        </div>
    </div>
</div>

<script src="/javascripts/sigma/sigma.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.parsers.json.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.layout.forceAtlas2.js"></script>
<script src="/javascripts/sigma/plugins/sigma.plugins.animate.min.js"></script>
<script src="/javascripts/jquery.min.js"></script>
<script src="/javascripts/jquery-ui.min.js"></script>

<script src="/javascripts/string.min.js"></script>

<script src="/javascripts/underscore-min.js"></script>
<script src="/javascripts/jquery.textcomplete.js"></script>
<script src='/javascripts/jquery.autosize.js'></script>
<script src="/javascripts/ui.js"></script>
<script src="/javascripts/jquery.mobile-events.min.js"></script>
<script src="/javascripts/jquery.highlight-4.js"></script>
<script src="/javascripts/bundle-stemmer.js"></script>
<script src="/javascripts/jquery.taghandler.js"></script>
<script src="/javascripts/socket.io.js"></script>
<script src="/javascripts/moment.min.js"></script>
<script type="text/javascript" src="/javascripts/jquery.tooltipster.min.js"></script>


<script>
    ;(function () {

        var urlPath = location.pathname;

        // Initialize Socket.IO
        var socket = io();


        // Get URL variables in the form of an array

        function getUrlVars() {
            var vars = [], hash;
            var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
            for (var i = 0; i < hashes.length; i++) {
                hash = hashes[i].split('=');
                vars.push(hash[0]);
                vars[hash[0]] = hash[1];
            }
            return vars;
        }


        // First we query URL parameters

        /* {

         Which queries to add to search keywords from the graph:
         "go_next_add": "keyword",
         Which website to refer people to with the keywords (include search string with URL)
         "go_next_url" : "http://soundcloud.com/search?q="
         }

         */

        var forwardTo = 'https://www.google.com/search?q=';

        var go_next_url = getUrlVars()["go_next_url"];

        var go_next_site = getUrlVars()["go_next_site"];

        var go_next_add = getUrlVars()["go_next_add"];

        var go_next_override = getUrlVars()["go_next_override"];

        var link_hashtags = getUrlVars()["link_hashtags"];

        var convert_hashtags = getUrlVars()["convert_hashtags"];

        var hide_always = getUrlVars()["hide_always"];

        var hide_when_small = getUrlVars()["hide_when_small"];

        var language = getUrlVars()["language"];

        var mute = getUrlVars()["mute"];

        if (go_next_url) {
            if ((go_next_url.substr(go_next_url.length - 1) == 's' || go_next_url.substr(go_next_url.length - 6) == 'search' || go_next_url.substr(go_next_url.length - 5) == 'query')) {
                go_next_url = go_next_url + '=';
            }
            forwardTo = go_next_url;
        }
        else if (go_next_site == 'soundcloud') {
            forwardTo = 'https://soundcloud.com/search?q=';
        }
        else if (go_next_site == 'youtube') {
            forwardTo = 'https://www.youtube.com/results?search_query=';
        }
        else if (go_next_site == 'wikipedia') {
            forwardTo = 'https://wikipedia.org/wiki/Special:Search?search=';
        }
        else if (go_next_site == 'amazon') {
            forwardTo = 'http://www.amazon.com/s/field-keywords=';
        }
        else if (go_next_site == 'twitter') {
            forwardTo = 'http://twitter.com/search?q=';
        }

        // For collaboration - Socket.IO chat
        var collaborate_invite = getUrlVars()["collaborate"];


// MAIN SETTINGS START

// Create node ID - Name index for filtering
        var nodeIDs = [];

// What are the concepts displayed - the opposite of above
        var nodeNames = [];

// Let's record all the unique edges we've got

        var edgesList = [];

// Create context-node index for filtering
        var contextNodeID = [];

// Create statement-node index for filtering
        var nodesOfStatement = [];

// What are the concepts present in the graph?
        var contextNames = [];

// What are the concepts present in the graph?
        var statementsOfContext = [];

        var current_context_field = [];

        var jsonpath = '';

        var addcontext = '';

// Path to the JSON graph file (specific context or a general one)路径JSON图文件(具体的上下文或一般)
        <% if (addcontext) { %>
        jsonpath = '/api/user/nodes/<%= context %>?addcontext=<%= addcontext %>';
        addcontext = "<%= addcontext %>";

        <% } else if (showcontexts) { %>
        jsonpath = '/api/user/nodes/<%= context %>?showcontexts=<%= showcontexts %>';
        addcontext = "";

        <% } else { %>
        jsonpath = '/api/user/nodes/<%= context %>';
        addcontext = "";
        <% } %>


// Is the user going to look at somebody else's graph?是用户要看别人的图?

        <% if (perceivername) { %>
        <% if (showcontexts && maxnodes) { %>
        jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?showcontexts=<%= showcontexts %>&maxnodes=<%= maxnodes %>';
        <% } else if (showcontexts) { %>
        jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?showcontexts=<%= showcontexts %>';
        <% } else if (maxnodes) { %>
        jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?maxnodes=<%= maxnodes %>';
        <% } else  { %>
        jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>';
        <% } %>
        <% } %>


// Get current context
        var path = window.location.pathname;
        var current_context = '<%= context %>';
        var current_user = path.replace(/^\/([^\/]*).*$/, '$1');
        var hostsite = window.location.host;


// These are the nodes clicked in the graph
        var pinnedNodes = [];
        var splicedNodes = [];
        var notfoundNodes = [];

// Whats the clicked nodes in the graph
        var clickedNodes = [];

// Inactivity timeout
        var inactiveTimeout = null;

// This variable shows if there was a meaningful interaction with the graph yet
        var graphInteraction = null;

// Loaded with graph only?
        var graphOnly = null;


// Who posted the message?
        var selfPosted = null;


// Socket.IO chat collaborate

// This matrix relates each URL path to each unique chat that can happen within that room

        var collaborate_matrix = {};

        var collaborate_room = urlPath + '/';

        var collaborate_id = '';

        var collaborate_content = '';

        var collaborate_message = '';

        var collaborate_html = '';

        var collaborate_storage = JSON.parse(localStorage.getItem("collaborate"));

// If the user opened a URL with collaborate=xxxxxx then they join the room that's the "url_path/xxxxxx"
        if (collaborate_invite) {
            collaborate_id = collaborate_invite;
        }
// Otherwise they join a room which is "url_path/randomnumber"
        else {
            collaborate_id = Math.round((Math.random() * 1000000));
        }

        collaborate_matrix[collaborate_room] = collaborate_room + collaborate_id;


        if (!collaborate_invite) {
            if (collaborate_storage) {

                if (collaborate_storage[collaborate_room]) {
                    if (collaborate_storage[collaborate_room].length > 0) {
                        collaborate_matrix[collaborate_room] = collaborate_storage[collaborate_room];
                        collaborate_id = collaborate_matrix[collaborate_room].split("/").pop();
                    }
                }
            }

            // Now in case the original user reloads the page by error, they'll get the new collaborate ID, so we avoid that by storing their data
            localStorage.setItem("collaborate", JSON.stringify(collaborate_matrix));
        }


        // On connection to server get the id of the current chat "room", which is actually the folder/URL of the current user

        socket.on('connect', function () {
            console.log('connected >>>');
            socket.emit('login', {
                user: current_user,
                context: current_context,
                id: collaborate_matrix[collaborate_room]
            });
        });


        socket.on('startChat', function (data) {
            console.log('chat started >>>');
            if (data.boolean && data.id == collaborate_matrix[collaborate_room]) {
                console.log('in chat room ' + data.id);
                var collab_content = $('#collaborate-link').tooltipster('content');
                $('#collaborate-link').tooltipster('content', 'Collaboration is ON');
                $('#collaborate-link').addClass('is-collab');
                $('#collaborate-link').tooltipster('show');
                /* setTimeout(function() {
                     $('#collaborate-link').tooltipster('hide');
                     setTimeout(function() {
                         $('#collaborate-link').tooltipster('content', collab_content);
                     }, 1000);

                 }, 2000);*/
            }
        });

        socket.on('leave', function (msg) {
            console.log('partner left >>>');
            console.log(msg.people);
            $('#collaborate-link').removeClass('is-collab');
            var collab_content = $('#collaborate-link').tooltipster('content');
            $('#collaborate-link').tooltipster('content', 'Collaboration is OFF');
            $('#collaborate-link').tooltipster('show');
            /*  setTimeout(function() {
                  $('#collaborate-link').tooltipster('hide');
                  setTimeout(function() {
                      $('#collaborate-link').tooltipster('content', collab_content);
                  }, 1000);
              }, 2000);*/
        });

        socket.on('tooMany', function (data) {

            console.log('one too many >>>');
            alert('已经有2个用户在这集,这是到目前为止我们的限定值限定上限。如果你认为是错误的,请检查你是否打开了任何额外的浏览器标签');
            window.location.href = 'http://' + hostsite + '/' + 'home' + '/edit';

        });


// The button to hide / show statements

        $("#graph-link").click(function (e) {
            e.preventDefault();

            // The user clicked on the graph icon, so we reset his graph interaction activity for timeout later
            graphInteraction = null;
            clearTimeout(inactiveTimeout);

            toggle_statements();
        });

        $("#windowdown-link").click(function (e) {
            e.preventDefault();
            if ((localStorage.getItem('folded') == 1)) {
                $('#entryform').css({top: 'auto', 'margin-top': '0px'});
                $('#entries').css({height: $(window).height() - $('#entryform').height() - 75});
                $("#entries").animate({scrollTop: $('#entries')[0].scrollHeight}, 1000);
                $('#deletecontext').show();
                $('#privacy-link').show();
                $('#collaborate-link').show();
                localStorage.setItem('folded', 0);
            }
            else {
                $('#entryform').css({top: $(window).height(), 'margin-top': '-50px'});
                $('#entries').css({height: $(window).height() - 80});
                $('#deletecontext').hide();
                $('#privacy-link').hide();
                $('#collaborate-link').hide();
                localStorage.setItem('folded', 1);
            }


        });


        document.addEventListener("DOMContentLoaded", function (event) {


            submitFormProcess();


        });


        function submitFormProcess() {

            document.querySelector('#submitform').addEventListener('submit', function (e) {

                e.preventDefault();


                $('#statement').addClass('loading');

                $('#submitbutton').attr('disabled', 'disabled');

                // We will set a user for posting. If the posting user does not equal the user who's watching the graph, we force-add the statement into theirs (provided they collaborate)
                var postedby = '';

                <% if (receivername) { %>
                postedby = '<%= receivername %>';
                <% } %>
                // TODO make it possible that those statements get submitted in both graphs

                // is urlvars mute off? then post as usual
                if (!mute) {
                    $.post('/post', $("#submitform").serialize())
                        .done(function (res) {
                            //3. Receive the server response, no need to emit an event
                            if (res.entryuid) {
                                //4. Show the updated text
                                selfPosted = '1';
                                $("#statement").val('');
                                $('#statement').removeClass('loading');
                                $('#submitbutton').removeAttr('disabled');
                                socket.emit('chat message', {
                                    postedby: postedby,
                                    entryuid: JSON.parse(res.entryuid).data,
                                    entrytext: res.entrytext,
                                    graph: res.graph
                                });
                                // This function will see what it has to say
                                infraTalk(5000);
                            }
                            else if (res.errormsg) {
                                $('#statement').removeClass('loading');
                                $('#submitbutton').removeAttr('disabled');
                                alert(res.errormsg);
                            }
                            else {
                                alert('Something went wrong, please, try again...');
                            }
                        })
                        .fail(function (res) {
                            alert("Server Error: " + res.status + " " + res.statusText);
                        });

                }
                // otherwise - make a dummy post - it appears in the list but doesn't get submitted into the graph
                else {
                    selfPosted = '1';
                    $('#statement').removeClass('loading');
                    $('#submitbutton').removeAttr('disabled');
                    $("#statement").val('');
                    socket.emit('chat message', {
                        mute: 1,
                        postedby: postedby,
                        entryuid: '',
                        entrytext: $('#statement').val(),
                        graph: ''
                    });
                }

                return false;
            });

            $('#statement').keypress(function (e) {

                // Submit the form on enter

                if (e.which == 13 && !e.shiftKey) {
                    e.preventDefault();
                    $('#submitbutton').trigger('click');
                }

            });

        }

// Hide / Show Statements DIV

        function toggle_statements() {

            /*$('#graph-link').toggleClass('graph-chat');
            $('#entries').toggleClass("hide-entries");
            $('#statements').toggleClass("hide-statements");

            if ($('#graph-link').hasClass('graph-chat')) {
                //$('#switcher-panel').toggleClass("hide-menu");
                $('#finds').trigger('click');
                $('#switcher-selector').toggleClass("hide-menu");
            }
            else {
                // $('#switcher-panel').toggleClass("hide-menu");
                $('#switcher-selector').toggleClass("hide-menu");
                if (pinnedNodes.length == 0) {
                    $('#adds').trigger('click');
                }
            }*/

            $("#statements").fadeToggle();
            if (!$("#chat-link").hasClass('chat-highlight')) {
                localStorage.setItem('graph', 1);
            }
            else {
                localStorage.setItem('graph', 0);
            }
            $("#chat-link").toggleClass('chat-highlight');


        }

        function showStatements() {
            var isHidden_ = $("#statements").is(":hidden");
            if (isHidden_) {
                $('#statements').fadeIn();
                $("#chat-link").toggleClass('chat-highlight');
            }
        }

        function showEntries() {
            var isHidden_ = $("#entries").is(":hidden");
            if (isHidden_) {
                $('#entries').fadeIn();
            }
        }


// Add a method to the graph model that returns an
// object with every neighbors of a node inside:

        sigma.classes.graph.addMethod('neighbors', function (nodeId) {
            var k,
                neighbors = {},
                index = this.allNeighborsIndex[nodeId] || {};

            for (k in index)
                neighbors[k] = this.nodesIndex[k];

            return neighbors;
        });

// Initialize JSON parser for SIGMA visualization

        if(jsonpath && jsonpath.length > 0){
            sigma.parsers.json(
                jsonpath,
                {
                    container: 'graph-container',
                    renderer: {
                        container: document.getElementById('graph-container'),
                        type: 'canvas'
                    },
                    settings: {
                        minNodeSize: 5,
                        maxNodeSize: 16,
                        minEdgeSize: 0.5,
                        maxEdgeSize: 2,
                        labelThreshold: 8
                    }
                },
                function (sigma) {

                    var i,
                        timeout = 4000,
                        nodes = sigma.graph.nodes(),
                        color_context = '#666',
                        color_addcontext = '#666688',
                        len = nodes.length;


                    // This is a fix for JSON
                    // Sigma requires that nodes have X, Y, Size and Color properties which our JSON doesn't have. So we add them.
                    // We also make the initial graph layout circular, so that ForceAtlas always looks the same

                    var maxnodesize = 0;

                    for (i = 0; i < len; i++) {
                        var nodesize = 0;
                        var angle = Math.PI * 2 * i / len;
                        nodes[i].x = Math.cos(angle);
                        nodes[i].y = Math.sin(angle);
                        nodes[i].size = sigma.graph.degree(nodes[i].id);
                        nodesize = nodes[i].size;
                        if (maxnodesize < nodesize) maxnodesize = nodesize;
                        nodes[i].color = color_context;
                    }

                    // We first need to save the original colors and LABELS of our
                    // nodes and edges, like this:

                    sigma.graph.edges().forEach(function (e) {

                        var unique_edge_id = '';

                        // Let's see if the edge source in alphabetical order is further than its target and change places

                        if (e.source > e.target) {
                            unique_edge_id = e.target + '-' + e.source;
                        }
                        else {
                            unique_edge_id = e.source + '-' + e.target;
                        }


                        // Let's make a unique list of edges to count how many there are of the same kind

                        if (edgesList[unique_edge_id]) {
                            ++edgesList[unique_edge_id];

                            // TODO this is a bit of a workaround - in the future could be better to distribute the weight evenly
                            e.size = e.weight + edgesList[unique_edge_id];
                        }
                        else {
                            edgesList[unique_edge_id] = 1;
                            e.size = e.weight;
                        }


                        e.originalColor = e.color;

                        // Make an index of nodes to context
                        if (contextNodeID[e.edge_context]) {
                            if (contextNodeID[e.edge_context].indexOf(e.source) < 0)
                                contextNodeID[e.edge_context].push(e.source);
                            if (contextNodeID[e.edge_context].indexOf(e.target) < 0)
                                contextNodeID[e.edge_context].push(e.target);
                        }
                        else {
                            contextNodeID[e.edge_context] = [];
                            contextNodeID[e.edge_context].push(e.source);
                            contextNodeID[e.edge_context].push(e.target);
                        }

                        // Make an index of nodes to statement
                        if (nodesOfStatement[e.statement_id]) {
                            if (nodesOfStatement[e.statement_id].indexOf(e.source) < 0)
                                nodesOfStatement[e.statement_id].push(e.source);
                            if (nodesOfStatement[e.statement_id].indexOf(e.target) < 0)
                                nodesOfStatement[e.statement_id].push(e.target);
                        }
                        else {
                            nodesOfStatement[e.statement_id] = [];
                            nodesOfStatement[e.statement_id].push(e.source);
                            nodesOfStatement[e.statement_id].push(e.target);
                        }

                        if (statementsOfContext[e.edge_context]) {
                            if (statementsOfContext[e.edge_context].indexOf(e.statement_id) < 0)
                                statementsOfContext[e.edge_context].push(e.statement_id);
                        }
                        else {
                            statementsOfContext[e.edge_context] = [];
                            statementsOfContext[e.edge_context].push(e.statement_id);
                        }

                    });

                    sigma.graph.nodes().forEach(function (n) {

                        // Check if the node is in additional context and if yes, give it a different color
                        if (addcontext) {
                            if (contextNodeID[addcontext].indexOf(n.id) > -1 && contextNodeID[current_context].indexOf(n.id) > -1) {
                                n.color = color_addcontext;
                            }
                        }


                        // Save node's default color, for hide and show later
                        n.originalColor = n.color;
                        n.originalLabel = n.label;

                        // Creating an index of node labels to IDs for filtering
                        nodeIDs[n.label] = n.id;

                        //console.log(n);

                    });


                    // Make a list of all the node labels displayed in the graph (for Autofill)

                    nodeNames = _.keys(nodeIDs);


                    // Get the context names - all the contexts that exist in the graph we just loaded
                    contextNames = _.keys(contextNodeID);


                    // Now we get the context IDs from the graph - a little bit of a workaround
                    var suspects = [];
                    var nonsuspects = [];

                    sigma.graph.edges().forEach(function (e) {

                        // If an edge has a context prefix, one of its nodes is a context, but we don't know which yet

                        if (e.id.substr(0, 7) == 'context') {
                            if (suspects.indexOf(e.source) < 0) {
                                suspects.push(e.source);
                            }

                            if (suspects.indexOf(e.target) < 0) {
                                suspects.push(e.target);
                            }

                        }

                        // If an edge doesn't have prefix context, for sure it has only nodes
                        else {
                            if (nonsuspects.indexOf(e.source) < 0) {
                                nonsuspects.push(e.source);
                            }

                            if (nonsuspects.indexOf(e.target) < 0) {
                                nonsuspects.push(e.target);
                            }
                        }


                    });

                    // Find the difference between two arrays above, so we get contexts only
                    var contextids = _.difference(suspects, nonsuspects);


                    // Now show those nodes that are contexts bigger and with a special label

                    for (i = 0; i < len; i++) {

                        if (contextids.indexOf(nodes[i].id) > -1) {
                            nodes[i].size = maxnodesize;
                            nodes[i].originalLabel = 'context: ' + nodes[i].originalLabel;
                            nodes[i].label = 'context: ' + nodes[i].label;
                        }


                    }


                    // Put the contexts into the menu

                    populateContextMenu(contextNames, nodeNames);


                    if (document.getElementById('context').value) {
                        current_context_field = [document.getElementById('context').value];
                        $("#addedContexts").val(document.getElementById('context').value);
                    }

                    // if not, we're making the 'private' context default
                    else {
                        var lastcontexts = [];
                        var laststatement = $(".entry:last").attr('data-uid');
                        console.log(laststatement);
                        for (var key in statementsOfContext) {
                            var reiteratestatements = statementsOfContext[key];
                            for (var i = 0; i < reiteratestatements.length; i++) {
                                if (laststatement == reiteratestatements[i]) {
                                    lastcontexts.push(key);
                                    console.log(key);
                                }
                            }

                        }
                        if (lastcontexts[0] == 'help' || !lastcontexts[0]) {
                            current_context_field = ['private'];
                            $("#addedContexts").val('private');
                        }

                        else {
                            current_context_field = lastcontexts;
                            $("#addedContexts").val(current_context_field.join());
                        }
                    }

                    // let's now populate contextHandlers

                    $("#addToContexts").tagHandler({
                        assignedTags: current_context_field,
                        availableTags: contextNames,
                        autocomplete: true,
                        afterAdd: function (tag) {
                            current_context_field.push(tag);
                            $("#addedContexts").val(current_context_field.join());
                            console.log('contexts in hidden field: ' + current_context_field.join());
                        },
                        afterDelete: function (tag) {
                            console.log('initiated delete from sigma');
                            for (var i = current_context_field.length - 1; i >= 0; i--) {
                                if (current_context_field[i] === tag) {
                                    current_context_field.splice(i, 1);
                                }
                            }
                            $("#addedContexts").val(current_context_field.join());
                            console.log('contexts in hidden field: ' + current_context_field.join());
                        }
                    });

                    // Do ForceAtlasLayout

                    sigma.startForceAtlas2();

                    // Don't run it forever not to overheat :)

                    setTimeout(function () {
                        sigma.stopForceAtlas2();
                    }, timeout);

                    // When a node is clicked, we check for each node
                    // if it is a neighbor of the clicked one. If not,
                    // we set its color as grey, and else, it takes its
                    // original color.
                    // We do the same for the edges, and we only keep
                    // edges that have both extremities colored.

                    sigma.bind('clickNode', function (e) {

                        // A node was clicked, so we assume there was a meaningful graph interaction
                        graphInteraction = 1;

                        var nodeLabel = e.data.node.originalLabel;


                        if (nodeLabel.substr(0, 9) == 'context: ') {
                            window.open('/' + current_user + '/' + nodeLabel.substr(9, nodeLabel.length) + '<% if (!perceivername) { %>/edit<% } %>', "_self");
                        }
                        else {

                            // Was the node clicked already? No? Add it to array of clicked nodes.
                            // Highlight the clicked node in the text.


                            if (splicedNodes.length > 1) {
                                pinnedNodes = [];
                                for (var p = 0; p < splicedNodes.length; p++) {
                                    pinnedNodes[p] = splicedNodes[p];
                                }
                            }
                            else if (splicedNodes.length == 1) {
                                pinnedNodes = [];
                                pinnedNodes[0] = splicedNodes[0];
                                splicedNodes = [];
                            }

                            if (pinnedNodes.indexOf(nodeLabel) < 0) {
                                pinnedNodes.push(nodeLabel);
                            }
                            else {
                                var pinnedIndex = pinnedNodes.indexOf(nodeLabel);
                                if (pinnedIndex > -1) {
                                    pinnedNodes.splice(pinnedIndex, 1);
                                    $('.entry').fadeIn(400);
                                }

                            }

                            // console.log("node clicked, now will filter for nodes " + pinnedNodes);
                            socket.emit('node click', {
                                pinnedNodes: pinnedNodes,
                                splicedNodes: splicedNodes,
                                nodeLabel: nodeLabel,
                                pinnedIndex: pinnedIndex
                            });


                            // Now show / hide statements that have the search field

                            filter_statements(pinnedNodes);


                            // If the window is wide enough to show the menu AND div with statements is not visible

                            var isHidden = $("#statements").is(":hidden");

                            if (isHidden) {

                                var delayShow = 6000;

                                clearTimeout(inactiveTimeout);
                                inactiveTimeout = setTimeout(showStatements, delayShow);

                                $('#graph-container').unbind('mousemove orientationchange scroll swipe tap swipeleft swiperight scrolltop');
                                $('#graph-container').bind('mousemove orientationchange scroll swipe tap swipeleft swiperight scrolltop', function () {
                                    if (graphInteraction) {
                                        clearTimeout(inactiveTimeout);
                                        inactiveTimeout = setTimeout(showStatements, delayShow);
                                    }
                                });


                            }

                        }

                    });


                    // Show node's label when we're over it

                    sigma.bind('overNode', function (e) {
                        e.data.node.label = e.data.node.originalLabel;
                        sigma.refresh();
                    });


                    // Hide node's label when we're out of it

                    sigma.bind('outNode', function (e) {
                        if (e.data.node.color != e.data.node.originalColor && pinnedNodes.indexOf(e.data.node.originalLabel) < 0) {
                            e.data.node.label = '';
                        }
                        sigma.refresh();
                    });

                    // Zoom Graph Control

                    var c = sigma.camera;


                    $("#zoom-in").on('click', function (e) {
                        // Zoom in - single frame :
                        c.goTo({
                            ratio: c.ratio / c.settings('zoomingRatio')
                        });
                    });

                    $("#zoom-out").on('click', function (e) {
                        // Zoom out - single frame :
                        c.goTo({
                            ratio: c.ratio * c.settings('zoomingRatio')
                        });
                    });

                    $("#improve-layout").on('click', function (e) {

                        sigma.startForceAtlas2();

                        // Don't run it forever not to overheat :)

                        setTimeout(function () {

                            sigma.stopForceAtlas2();
                        }, 3000);

                    });


                    // Forward from the graph function

                    $("#go_next").on('click', function (e) {

                        var searchQuery = pinnedNodes.join("+");


                        if (go_next_add) {
                            searchQuery = searchQuery + '+' + go_next_add;
                        }

                        if (searchQuery.length > 0 || go_next_add) {

                            if (go_next_override) {
                                if (pinnedNodes.length > go_next_override) {
                                    window.open('http://google.com/search?q=' + searchQuery, '_blank');
                                }
                                else {
                                    window.open(forwardTo + searchQuery, '_blank');
                                }
                            } else {
                                window.open(forwardTo + searchQuery, '_blank');
                            }
                        }
                        else {
                            alert("Click this after you select a few nodes to find them on the web.");
                        }


                    });


                    // Here we perform some live updates of the graph on receiving a Socket.IO message
                    // We could also move this code and use sigma.instances(0).graph.nodes() to get sigma properties

                    // TODO set up chatroom, make better design, think of graph sharing functionality

                    socket.on('chat message', function (msg) {

                        var posted_by = msg.postedby;

                        var added_entry = "<div class='entry' style='display: none;' data-uid='" + msg.entryuid + "'><p class='entry-text'>" + msg.entrytext + "</p><p class='entry-date'>by " + posted_by + " at " + moment().format('hh:mm:ss') + "</p><div class='separator'>&nbsp;</div><div id='" + msg.entryuid + "' class='hidden'></div></div>";

                        if (!selfPosted) {

                            added_entry = "<div class='entry alien' style='display: none; margin-left: 50px' data-uid='" + msg.entryuid + "'><p class='entry-text gray'>" + msg.entrytext + "</p><p class='entry-date gray'>by " + posted_by + " at " + moment().format('hh:mm:ss') + "</p><div class='separator'>&nbsp;</div><div id='" + msg.entryuid + "' class='hidden'></div></div>";

                            if (msg.help) {
                                added_entry = "<div class='entry alien' style='display: none; margin-left: 50px' data-uid='" + msg.entryuid + "'><p class='entry-text gray'>" + msg.entrytext + "</p><p class='entry-date gray'>help tip &nbsp;<em></em><a href='javascript:' class='disablehelp'>disable</a></em></p><div class='separator'>&nbsp;</div><div id='" + msg.entryuid + "' class='hidden'></div></div>";
                            }

                            // We will set a user for receiving. If the posting user does not equal the user who's watching the graph, we force-add the statement into theirs (provided they collaborate)
                            var receivedby = '';

                            <% if (perceivername) { %>
                            receivedby = '<%= perceivername %>';
                            <% } %>
                            // TODO make it possible that those statements get submitted in both graphs

                            // So the user who posted is not the same who's receiving? then submit the form. If the sender didnt have the mute option
                            if ((receivedby != msg.postedby) && !msg.mute) {


                                /*var temporary_statement = $('#statement').val();
                                $('#statement').val(msg.entrytext);
                                console.log($("#submitform").serialize());*/

                                var to_submit = $('#submitform').serializeArray();

                                for (key in to_submit) {
                                    if (to_submit[key].name == 'entry[body]') {
                                        to_submit[key].value = msg.entrytext;
                                    }
                                }

                                $.post('/post', $.param(to_submit))
                                    .done(function (res) {

                                        /*          $('#statement').val(temporary_statement);*/

                                        //3. Receive the server response, no need to emit an event
                                        if (res.entryuid) {
                                            //4. Show the updated text
                                            console.log('submitted externally');
                                        }
                                        else if (res.errormsg) {
                                            alert(res.errormsg);
                                        }
                                        else {
                                            alert('Something went wrong, please, try again...');
                                        }
                                    })
                                    .fail(function (res) {
                                        alert("Server Error: " + res.status + " " + res.statusText);
                                    });

                            }


                        }
                        else {
                            selfPosted = null;
                        }

                        $(added_entry).appendTo($('#entries')).slideDown("fast");
                        $("#entries").animate({scrollTop: $('#entries')[0].scrollHeight}, 1000);

                        //$('#entries').append(added_entry).slideUp("fast");

                        if ($(window).height() < 600) {
                            document.activeElement.blur();
                        }


                        entryClick();
                        entryDoubleClick();

                        var addednodes = msg.graph.nodes;
                        var addededges = msg.graph.edges;


                        for (var i = 0; i < addednodes.length; i++) {

                            if (nodeNames.indexOf(addednodes[i].label) == -1) {

                                // var angle = Math.PI * 2 * i / len;

                                sigma.graph.addNode({
                                    id: (id = addednodes[i].id),
                                    label: addednodes[i].label,
                                    originalLabel: addednodes[i].label,
                                    originalColor: color_context,
                                    size: maxnodesize - 2,
                                    x: Math.random(),
                                    y: Math.random(),
                                    color: color_context
                                });
                                nodeNames.push(addednodes[i].label);


                            }
                        }

                        for (var j = 0; j < addededges.length; j++) {

                            if ((addededges[j].statement_id == msg.entryuid)) {

                                sigma.graph.addEdge({
                                    id: addededges[j].id,
                                    source: addededges[j].source,
                                    target: addededges[j].target,
                                    weight: addededges[j].weight,
                                    size: addededges[j].weight,
                                    statement_id: addededges[j].statement_id,
                                    edge_context: addededges[j].edge_context
                                });

                            }

                        }

                        sigma.graph.nodes().forEach(function (n) {
                            if (n.id == 'dummy') {
                                sigma.graph.dropNode('dummy');
                            }
                            n.size = sigma.graph.degree(n.id);

                        });

                        // TODO this code duplicates from above - move into a function
                        sigma.graph.edges().forEach(function (e) {
                            // Make and index of nodes to statement
                            if (nodesOfStatement[e.statement_id]) {
                                if (nodesOfStatement[e.statement_id].indexOf(e.source) < 0)
                                    nodesOfStatement[e.statement_id].push(e.source);
                                if (nodesOfStatement[e.statement_id].indexOf(e.target) < 0)
                                    nodesOfStatement[e.statement_id].push(e.target);
                            }
                            else {
                                nodesOfStatement[e.statement_id] = [];
                                nodesOfStatement[e.statement_id].push(e.source);
                                nodesOfStatement[e.statement_id].push(e.target);
                            }

                            if (statementsOfContext[e.edge_context]) {
                                if (statementsOfContext[e.edge_context].indexOf(e.statement_id) < 0)
                                    statementsOfContext[e.edge_context].push(e.statement_id);
                            }
                            else {
                                statementsOfContext[e.edge_context] = [];
                                statementsOfContext[e.edge_context].push(e.statement_id);
                            }
                        });

                        sigma.refresh();

                        sigma.startForceAtlas2();

                        // Don't run it forever not to overheat :)

                        setTimeout(function () {

                            sigma.stopForceAtlas2();

                        }, 3000);

                        //console.log(newnodes);
                        // console.log(msg.graph.edges);
                        // console.log(sigma.graph.edges());


                    });


                    socket.on('delete message', function (msg) {


                        $('[data-uid="' + msg.entryuid + '"]').fadeOut();

                        $("#statement").val('');

                        // When searched for nodes in that statement, nothing will appear.

                        nodesOfStatement[msg.entryuid] = [];

                        var nodesToKeep = [];

                        sigma.graph.edges().forEach(function (e) {

                            // If a node appears in at least one statement, we add him in ToKeep list
                            if (nodesOfStatement[e.statement_id].indexOf(e.source) > -1) {
                                nodesToKeep.push(e.source);
                            }

                            if (nodesOfStatement[e.statement_id].indexOf(e.target) > -1) {
                                nodesToKeep.push(e.target);
                            }

                            var statePosition = statementsOfContext[e.edge_context].indexOf(e.statement_id);
                            if (statePosition < 0) {
                                statementsOfContext[e.edge_context].splice(statePosition, 1);
                            }


                        });


                        sigma.graph.nodes().forEach(function (n) {
                            if (nodesToKeep.indexOf(n.id) < 0) {
                                sigma.graph.dropNode(n.id);
                            }

                        });

                        sigma.refresh();

                        sigma.startForceAtlas2();

                        // Don't run it forever not to overheat :)

                        setTimeout(function () {

                            sigma.stopForceAtlas2();

                        }, 3000);

                        //console.log(newnodes);
                        // console.log(msg.graph.edges);
                        // console.log(sigma.graph.edges());


                    });


                }
            );
        }


        var visibleentries_original = '0';

// TODO: 1. Add search function by #hashtag; 2. Attach that same function to hashtag doubleclick;

// Auto-resize to fill content;

        $(document).ready(function () {

            $('.tooltip').tooltipster({
                theme: 'tooltipster-noir',
                position: 'left',
                maxWidth: 200,
                delay: 1000

            });

            var privacyform = '';

            var graph_share_url = hostsite + '/' + current_user;

            if (current_context) {
                graph_share_url = graph_share_url + "/" + current_context;
            }

            var privacy_iframe = "<iframe width='100%' height='500' style='height: 500px' src='http://" + graph_share_url + "?hide_always=1&link_hashtags=1' frameborder='0' allowfullscreen></iframe>";

            <% if (contextpublic && context && !perceivername && entries.length > 0) { %>
            privacyform = $('<span><form action="/context" name="privacycontext" method="post" class="pure-form"><input type="hidden" name="context" value="<%= context %>">This set can be viewed on:<br><input type="text" id="embedurl" size="25" maxlength="80" class="pure-input" value="http://' + graph_share_url + '"><br><br>Embed code for websites:<br><input type="text" id="embedcode" size="25" maxlength="100" class="pure-input" value="' + privacy_iframe + '"><br><br><input type="submit" id="privacybutton" name="privacy" value="make private"></form></span>')

            <% } else if (!perceivername && context && entries.length > 0) { %>
            privacyform = $('<span><form action="/context" name="privacycontext" method="post" class="pure-form"><input type="hidden" name="context" value="<%= context %>">This set is currently private and cannot be seen by the public.<br><br><input type="submit" id="privacybutton" name="privacy" value="make public"></form></span>')
            <% } %>

            $('#privacy-link').tooltipster({
                theme: 'tooltipster-noir',
                position: 'top-right',
                maxWidth: 220,
                interactive: true,
                content: privacyform,
                functionReady: function () {
                    $('#embedurl').focus(function (event) {
                        setTimeout(function () {
                            $('#embedurl').select();
                        }, 0);
                    });
                    $('#embedcode').focus(function (event) {
                        setTimeout(function () {
                            $('#embedcode').select();
                        }, 0);
                    });
                }
            });


            collaborate_message = '<a href="mailto:chat@infranodus.com?subject=Chat%20Now&body=http://' + graph_share_url + '/edit?collaborate=' + collaborate_id + '">Invite us</a> or other people for a real-time constellaversation – just share the link below:<br>';

            collaborate_html = '<span><form class="pure-form">' + collaborate_message + '<input type="text" id="collaburl" size="22" maxlength="80" class="pure-input" value="http://' + graph_share_url + '/edit?collaborate=' + collaborate_id + '"></form></span>';

            collaborate_content = $(collaborate_html);

            $('#collaborate-link').tooltipster({
                theme: 'tooltipster-noir',
                position: 'top-right',
                maxWidth: 220,
                interactive: true,
                content: collaborate_content,
                functionReady: function () {
                    $('#collaburl').focus(function (event) {
                        this.setSelectionRange(0, 9999);
                    });
                }
            });







            <% if (!perceivername) { %>

            // Advertise graph collaboration module
            if (!collaborate_invite) {
                var collab_content = $('#collaborate-link').tooltipster('content');

                var graph_share_url = hostsite + '/' + current_user;

                if (current_context) {
                    graph_share_url = graph_share_url + "/" + current_context;
                }

                var collab_invite = '<a href="mailto:chat@infranodus.com?subject=Chat%20Now&body=http://' + graph_share_url + '/edit?collaborate=' + collaborate_id + '">Chat Now!</a><br>';

                var times_seen = localStorage.getItem('TooltipSeen');

                if (times_seen >= 1) {
                    localStorage.setItem('TooltipSeen', parseInt(times_seen) + 1);
                }
                else {
                    localStorage.setItem('TooltipSeen', 1);
                }

                if (times_seen < 4) {
                    $('#collaborate-link').tooltipster('content', $(collab_invite));
                    $('#collaborate-link').tooltipster('show');
                    setTimeout(function () {
                        $('#collaborate-link').tooltipster('hide');
                        setTimeout(function () {
                            $('#collaborate-link').tooltipster('content', collab_content);
                        }, 1000);
                    }, 2000);
                }
                else if (times_seen > 15) {
                    localStorage.setItem('TooltipSeen', 1);
                }
            }

            // START Speech Recognition Module only for Chrome

            if ('webkitSpeechRecognition' in window) {

                var recognition = new webkitSpeechRecognition();

                $('#microphone-link').fadeIn();

                if (localStorage.getItem('microphone') == 1) {
                    $('#microphone-link').toggleClass('microphone-on', 'add');
                    activateVoiceInput();
                }

                $("#microphone-link").click(function (e) {

                    e.preventDefault();

                    if (localStorage.getItem('microphone') == 1) {
                        localStorage.setItem('microphone', 0);
                        $('#microphone-link').toggleClass('microphone-on', 'remove');
                        recognition.abort();
                    }
                    else {
                        localStorage.setItem('microphone', 1);
                        activateVoiceInput();
                        $('#microphone-link').toggleClass('microphone-on', 'add');
                    }

                });

            }


            function activateVoiceInput() {


                var voiceresult = '';

                var previoustalk = '';

                // Are we processing a short phrase or performing continuous dictation?
                recognition.continuous = false;

                // Do we require interim results in addition to the final results?
                recognition.interimResults = true;

                // We speak The US English here
                recognition.lang = 'en-US';

                if (language == 'en' || language == 'en-US') {
                    localStorage.setItem('language', 'en');
                }

                else if (language == 'ru' || language == 'russian') {
                    recognition.lang = 'ru';
                    localStorage.setItem('language', 'ru');
                }

                if (localStorage.getItem('language') == 'ru') {
                    recognition.lang = 'ru';
                    localStorage.setItem('language', 'ru');
                }

                // Kick off the Speech to Text recognition process
                recognition.start();

                // Set up
                recognition.onstart = function (event) {
                    console.log("onstart", event);
                }
                // Set up
                recognition.onspeechstart = function (event) {
                    console.log("onspeechstart", event);
                }

                // Process parsed result
                recognition.onresult = function (event) {
                    // console.log("onresult", event);
                    voiceresult = previoustalk + event.results[0][0].transcript;
                    $('#statement').val(voiceresult);
                    console.log(event.resultIndex);
                    for (var i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            recognition.abort();
                            if (voiceresult.length > 4) {
                                setTimeout(function () {
                                    $('#submitbutton').trigger('click');
                                }, 1000);

                            }
                            else {
                                previoustalk = voiceresult + ' ';
                                // recognition.start();
                            }
                        }
                    }
                }

                // Handle error
                recognition.onerror = function (event) {
                    console.log("onerror", event);
                    if (event.error == 'no-speech') {

                    }
                }

                /*  // Housekeeping after success or failed parsing
                  recognition.onspeechend = function(){
                      console.log("onspeechend");
                      if (voiceresult.length > 4) {
                          setTimeout(function(){
                              $('#submitbutton').trigger('click');
                          }, 1000);

                      }
                      else {
                          previoustalk = voiceresult + '';
                          // recognition.start();
                      }

                  }*/


                recognition.onend = function () {

                    console.log("onend");
                    if (localStorage.getItem('microphone') == 1) {
                        recognition.start();
                    }

                }


            }


            // END Speech recognition module


            <% } %>



            $("#chat-link").click(function (e) {
                e.preventDefault();

                // The user clicked on the graph icon, so we reset his graph interaction activity for timeout later
                graphInteraction = null;
                clearTimeout(inactiveTimeout);

                toggle_statements();


            });

            $("#imports").click(function (e) {
                var fornode = '';
                if (pinnedNodes.length > 0) {
                    fornode = toTitleCase(pinnedNodes[pinnedNodes.length - 1].replace(/_/g, " "));
                }
                $(this).attr("href", "/import?context=<%= context %>&fornode=" + fornode);
            });

            function toTitleCase(str) {
                return str.replace(/\w\S*/g, function (txt) {
                    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                });
            }

            // Activate content switcher Set1 and set delay time for fade
            jcps.fader(0, '#switcher-panel', '.set1');


            $('#entries').css({height: $(window).height() - $('#entryform').height() - 100});

            $(window).resize(function () {
                $('#entries').css({height: $(window).height() - $('#entryform').height() - 100});
                $("#entries").animate({scrollTop: $('#entries')[0].scrollHeight}, 1000);
            });

            $("#entries").animate({scrollTop: $('#entries')[0].scrollHeight}, 1000);


            $('#switcher-selector').on('click', 'li', function () {


                $('#topmenuitems').each(function () {
                    $("li", this).each(function (i) {
                        $(this).removeClass('pure-menu-selected-top');
                    });
                });

                this.className = 'pure-menu-selected-top';


                var topmenuaction = $(this).children(":first").attr('id');

                // Repopulate context for addition field if it was the one clicked

                if (topmenuaction == 'adds') {

                    current_context_field = [];

                    // Are we inside some context already?

                    if (document.getElementById('context').value) {
                        current_context_field.push(document.getElementById('context').value);
                        $("#addedContexts").val(document.getElementById('context').value);
                    }

                    // if not, we're making the 'private' context default
                    else {
                        var lastcontexts = [];
                        var laststatement = $(".entry:last").attr('data-uid');
                        console.log(laststatement);
                        for (var key in statementsOfContext) {
                            var reiteratestatements = statementsOfContext[key];
                            for (var i = 0; i < reiteratestatements.length; i++) {
                                if (laststatement == reiteratestatements[i]) {
                                    lastcontexts.push(key);
                                    console.log(key);
                                }
                            }

                        }
                        if (lastcontexts[0] == 'help') {
                            current_context_field = ['private'];
                            $("#addedContexts").val('private');
                        }
                        else {
                            current_context_field = lastcontexts;
                            $("#addedContexts").val(current_context_field.join());
                        }
                    }

                    $("#addToContexts").tagHandler({
                        assignedTags: current_context_field,
                        availableTags: contextNames,
                        autocomplete: true,
                        afterAdd: function (tag) {
                            current_context_field.push(tag);
                            $("#addedContexts").val(current_context_field.join());
                            console.log('contexts in cancel field: ' + current_context_field.join());
                        }
                    });

                    submitFormProcess();


                }


                // Autocomplete for search input
                $("#search").autocomplete({
                    source: nodeNames,
                    minLength: 1,
                    delay: 500,
                    messages: {
                        noResults: '',
                        results: function () {
                        }
                    },
                    select: function (event, ui) {

                        var filter = ui.item.value;


                    }

                });

                search_graph();


            });

            // Autocomplete for search input
            $("#search").autocomplete({
                source: nodeNames,
                minLength: 1,
                delay: 500,
                messages: {
                    noResults: '',
                    results: function () {
                    }
                },
                select: function (event, ui) {

                    var filter = ui.item.value;


                }

            });

            search_graph();

            // Make texarea automatically resizeable
            $('textarea').autosize();

            visibleentries_original = $(".entry:visible").length;

            // Statement edit / delete functionality

            var filteringstarted = 0;


            entryClick();

            // If it's NOT some other user watching the graph, then statements can be edited. Otherwise - no.
            <% if (!perceivername) { %>
            entryDoubleClick();


            infraTalk();
            <% } %>


            // Highlight statement if clicked once


            // Deal with each date

            $(".entry-date").each(function () {
                var convertedTime = timeConverter($(this).text());
                $(this).text(convertedTime);
            });


            function timeConverter(UNIX_timestamp) {
                var modTimestamp = UNIX_timestamp.substr(0, UNIX_timestamp.length - 4);
                var time = moment(modTimestamp, 'x').fromNow();
                return time;
            }

            if (hide_always) {
                toggle_statements();
                //localStorage.setItem('graph', 1);
            }

            if (hide_when_small) {
                if ($('#menuLink').is(':visible')) {
                    toggle_statements();
                    //localStorage.setItem('graph', 1);
                }

            }


// Are we loading the page to only show the graph?

            <% if (background == '1' || background == 'graph') { %>
            // $('#finds').trigger('click');

            toggle_statements();
            //localStorage.setItem('graph', 1);
            graphOnly = 1;
            <% } %>

            if (localStorage.getItem('graph') == 1 && !graphOnly && !hide_always && !hide_when_small) {
                var isHidden__ = $("#statements").is(":hidden");
                if (!isHidden__) {
                    $('#statements').fadeOut();
                    $("#chat-link").toggleClass('chat-highlight', 'add');
                }
            }

            socket.on('node click', function (msg) {

                pinnedNodes = msg.pinnedNodes;
                splicedNodes = msg.splicedNodes;
                var pinnedIndex = msg.pinnedIndex;

                // Are we clicking the node that was clicked already? Then show all divs
                if (pinnedIndex > -1) {
                    $('.entry').fadeIn(400);
                }

                // Filter statements and select nodes on the graph
                filter_statements(pinnedNodes);

            });


        });


        // Textarea select conversion to hashtags

        // For now it's disabled, but will be enabled for bulk statement correction later

        /*var getSelected = function(){
            var t = '';
            if(window.getSelection) {
                t = window.getSelection();
            } else if(document.getSelection) {
                t = document.getSelection();
            } else if(document.selection) {
                t = document.selection.createRange().text;
            }
            return t;
        }

        $("#statement").select(function(eventObject) {
            var selectedText = getSelected().toString();

            var statementReplace = $("#statement").val();

            if ((statementReplace.indexOf('@'+selectedText) === -1) && (selectedText !== statementReplace)) {

                var regex = RegExp(selectedText, "g");

                var dasherized = S(selectedText).dasherize().chompLeft('-').s;

                // TODO check words for morphology (if found, alert)

                var replacedString = statementReplace.replace(regex,"#" + dasherized).replace(/##/g,'#');
                $("#statement").val(replacedString);
            }

        });*/


        function entryClick() {

            $(".entry").on('click', function (e) {
                if (e.target.className == 'app-link-menu') {

                    if ($(this).find('.app-link-menu').text() == 'hide filtered') {
                        $(this).find('.nonmatched-sentence').fadeOut(400);
                        $(this).find('.app-link-menu').text('show filtered');
                    }
                    else {
                        $(this).find('.nonmatched-sentence').fadeTo(400, '0.4');
                        $(this).find('.app-link-menu').text('hide filtered');
                    }

                }


                // A parameter to check if we're taking off the flag

                var alreadyClicked = null;

                // Make all entries semitrasparent


                if (pinnedNodes.length == 0) {

                    $(".entry").each(function () {
                        if ($(this).css('opacity') < 1) {
                            $(this).css('opacity', '1');
                            alreadyClicked = 1;
                        }
                        else {
                            $(this).css('opacity', '0.3');
                        }
                    });

                    // The one clicked is not transparent

                    $(this).css('opacity', '1');

                }


                var keepStatementID = e.currentTarget.dataset.uid;


                console.log(keepStatementID);

                // Make only those edges visible that belong to the statement selected

                if (!alreadyClicked && pinnedNodes.length == 0) {

                    sigma.instances(0).graph.edges().forEach(function (e) {

                        if (e.statement_id == keepStatementID) {
                            e.color = e.originalColor;
                        }
                        else {
                            e.color = '#ddd';
                        }

                    });

                    // Make only those nodes visible that belong to the statement selected

                    sigma.instances(0).graph.nodes().forEach(function (n) {

                        // Is there no contexts at all? Show the node.
                        if (nodesOfStatement[keepStatementID].indexOf(n.id) < 0) {
                            n.color = '#ddd';
                            n.label = '';
                        }
                        else {
                            n.color = n.originalColor;
                            n.label = n.originalLabel;
                        }
                    });
                }
                else if (e.target.className == 'app-link-menu') {

                    // Do nothing

                }
                else {

                    if (pinnedNodes.length == 0) {
                        sigma.instances(0).graph.edges().forEach(function (e) {
                            e.color = e.originalColor;
                        });

                        // Make only those nodes visible that belong to the statement selected

                        sigma.instances(0).graph.nodes().forEach(function (n) {
                            n.color = n.originalColor;
                            n.label = n.originalLabel;
                        });
                    }

                }

                sigma.instances(0).refresh();
            });

        }


        function entryDoubleClick() {

            $(".entry").on('doubletap', function (e) {

                e.preventDefault();

                // Get the content from the form edit and copy it into the switcher panel to show to the user

                var _formcontent = $('#adds-content').html();

                $("#switcher-panel").html(_formcontent);

                // Get the statement into the edit box at the top
                $("#statement").val($('.entry-text', e.currentTarget).text());

                // Retrieve that statement's ID into the hidden field (for edit or delete)
                $('input[name="statementid"]').val(e.currentTarget.dataset.uid);

                // Retrieve the date of the statement
                $('input[name="timestamp"]').val(e.currentTarget.dataset.timestamp);

                $('#topmenuitems').each(function () {
                    $("li", this).each(function (i) {

                        $(this).removeClass('pure-menu-selected-top');

                    });
                });


                // Change / add buttons
                $('#submitbutton').hide();

                if (!$('#deletebutton').val()) {

                    $("#submitform").append('<input type="submit" name="edit" value="edit" id="editbutton" class="pure-button"> <input type="submit" style="margin: 0px 8px;" name="delete" value="delete" id="deletebutton" > <input type="submit" name="cancel" value="cancel" id="cancelbutton" class="pure-button">');

                    $('#deletecontextbutton').hide();
                    $('#privacy-link').hide();
                    $('#collaborate-link').hide();


                    // Delete text from the form in case of Cancel, remove the buttons

                    $("#cancelbutton").on('click', function (e) {

                        e.preventDefault();

                        $("#statement").val('');
                        $('#editbutton').remove();
                        $('#deletebutton').remove();
                        $('#cancelbutton').remove();
                        $('#submitbutton').show();
                        $('#deletecontextbutton').show();
                        $('#privacy-link').show();
                        $('#collaborate-link').show();

                        $("#entries").animate({scrollTop: $('#entries')[0].scrollHeight}, 1000);

                        $('input[name="timestamp"]').val('');

                        // Populate contexts list next to statement add

                        current_context_field = [];

                        // Are we inside some context already?

                        if ($("#context").val()) {
                            current_context_field.push($("#context").val());
                            $("#addedContexts").val($("#context").val());
                        }

                        else {

                            if (document.getElementById('context').value) {
                                current_context_field.push(document.getElementById('context').value);
                                $("#addedContexts").val(document.getElementById('context').value);
                            }

                            // if not, we're making the 'private' context default
                            else {
                                var lastcontexts = [];
                                var laststatement = $(".entry:last").attr('data-uid');
                                console.log(laststatement);
                                for (var key in statementsOfContext) {
                                    var reiteratestatements = statementsOfContext[key];
                                    for (var i = 0; i < reiteratestatements.length; i++) {
                                        if (laststatement == reiteratestatements[i]) {
                                            lastcontexts.push(key);
                                            console.log(key);
                                        }
                                    }

                                }
                                if (lastcontexts[0] == 'help') {
                                    current_context_field = ['private'];
                                    $("#addedContexts").val('private');
                                }
                                else {
                                    current_context_field = lastcontexts;
                                    $("#addedContexts").val(current_context_field.join());
                                }
                            }


                        }


                        $("#addToContexts").tagHandler({
                            assignedTags: current_context_field,
                            availableTags: contextNames,
                            autocomplete: true,
                            afterAdd: function (tag) {
                                current_context_field.push(tag);
                                $("#addedContexts").val(current_context_field.join());
                                console.log('contexts in cancel field: ' + current_context_field.join());
                            }
                        });

                        // TODO a better way of dealing with delete and edit - in the logic of everything else

                        submitFormProcess();


                    });

                    $("#deletebutton").on('click', function (e) {
                        e.preventDefault();

                        $('#statement').addClass('loading');

                        $('#deletebutton').attr('disabled', 'disabled');

                        $('input[name="timestamp"]').val('');


                        var formSubmit = $("#submitform").serialize() + '&delete=delete';

                        $.post('/post', formSubmit)
                            .done(function (res) {
                                //3. Receive the server response, no need to emit an event
                                console.log(res);
                                if (res.successmsg) {
                                    //4. Show the updated text
                                    selfPosted = '1';
                                    $('#statement').removeClass('loading');
                                    $('#deletebutton').removeAttr('disabled');
                                    socket.emit('delete message', {entryuid: res.statementid});
                                    $("#warnings").append('<p class="warning">The statement was deleted.</p>');
                                    $("#warnings").slideDown('slow');
                                    $('#cancelbutton').trigger('click');
                                    setTimeout(function () {
                                        $("#warnings").slideUp('slow');
                                        $("#warnings").text('');
                                    }, 2000);


                                }
                                else if (res.errormsg) {
                                    alert(res.errormsg);
                                }
                                else {
                                    alert('Something went wrong, please, try again...');
                                }
                            })
                            .fail(function (res) {
                                alert("Server Error: " + res.status + " " + res.statusText);
                            });


                    });

                    $("#editbutton").on('click', function (e) {
                        e.preventDefault();

                        $('#statement').addClass('loading');

                        $('#editbutton').attr('disabled', 'disabled');

                        var statementToHide = $('#statementid').val();

                        $('[data-uid="' + statementToHide + '"]').slideUp();

                        var formSubmit = $("#submitform").serialize() + '&edit=edit';

                        $.post('/post', formSubmit)
                            .done(function (res) {
                                //3. Receive the server response, no need to emit an event
                                if (res.entryuid) {
                                    //4. Show the updated text
                                    selfPosted = '1';
                                    $('#statement').removeClass('loading');
                                    $('#editbutton').removeAttr('disabled');
                                    $('#cancelbutton').trigger('click');
                                    socket.emit('chat message', {
                                        entryuid: JSON.parse(res.entryuid).data,
                                        entrytext: res.entrytext,
                                        graph: res.graph
                                    });
                                }
                                else if (res.errormsg) {
                                    alert(res.errormsg);
                                }
                                else {
                                    alert('Something went wrong, please, try again...');
                                }
                            })
                            .fail(function (res) {
                                alert("Server Error: " + res.status + " " + res.statusText);
                            });


                    });


                }


                current_context_field = [];

                for (var key in statementsOfContext) {
                    var checkstatements = statementsOfContext[key];
                    for (var l = 0; l < checkstatements.length; l++) {
                        if (checkstatements[l] == e.currentTarget.dataset.uid) {
                            current_context_field.push(key);
                        }
                    }

                }

                console.log('context of statement clicked: ' + current_context_field);

                // Which contexts the statement should be in?
                $("#addedContexts").val(current_context_field.join());

                // Update the contexts list if anything changes in the context settings of the statement

                $("#addToContexts").tagHandler({
                    assignedTags: current_context_field,
                    availableTags: contextNames,
                    autocomplete: true,
                    afterAdd: function (tag) {
                        current_context_field.push(tag);
                        $("#addedContexts").val(current_context_field.join());
                        console.log('contexts in statement field: ' + current_context_field.join());
                    }
                });


                // Smoothly scroll up
                $("html, body").animate({scrollTop: 0}, "slow");


                // THIS WAS BEFORE WHEN YOU CLICK A STATEMENT ONCE

                // Shall all statements inside Entry if clicked


            });
        }

        // Initial conversation with the user - HELP of a sorts

        function infraTalk(timer) {
            if (localStorage.getItem('disablehelp') != 1) {
                if (!timer) {
                    var timer = 3000;
                }
                var utterance = '';
                var vocabulary = [];

                if (!current_context) {
                    vocabulary = [
                        "Let's start from a clear page... What are you interested in thinking about?",
                        "Can you say something else about it?"
                    ];
                }
                else {
                    vocabulary = [
                        "To start, write your ideas, import data, or invite somebody to collaborate using the icon below..."
                    ];
                    timer = 10000;
                }

                var visibleentries_current = $(".entry:visible").length;

                if (!visibleentries_current || visibleentries_current == null) {
                    visibleentries_current = 0;
                }
                var pose = visibleentries_current;
                utterance = vocabulary[pose];
                if (utterance) {
                    setTimeout(function () {
                        socket.emit('chat message', {
                            mute: 1,
                            postedby: 'infratalk',
                            entryuid: '',
                            entrytext: utterance,
                            graph: '',
                            help: 1
                        });
                    }, timer);
                }
            }

        }


        // Filter out the statements that don't have any of the nodes clicked

        var timesfiltered = 0;


        function filter_statements(pinnedNodes, origin) {


            var showingsomething = 0;

            var visibleentries = visibleentries_original;

            // Hide the sentences that don't contain the terms

            $(".entry").each(function () {

                var currentDiv = $(this).attr('data-uid');

                // Retrieve the statement text from the entry, clean from html
                var originaltext = $(this).children('.entry-text').html();

                // Make an array from sentences of that text
                var sentences = originaltext.split(/[.|!|?]\s/gi);

                var searchlemmas = [];


                // START Check what sentences contain the node clicked

                var startmark = sentences.length; // How many sentences are inside

                for (var i = 0; i < sentences.length; i++) {

                    // What language is the sentence?
                    var sentence_cyrillic = sentences[i].match(/[а-яА-Я]/);

                    var nodesfound = 0;

                    // Transform the sentence into a series of morphemes
                    var sentences_lemmas = sentences[i].split(' ');

                    // SEARCH MOD
                    /*for (var z = 0; z < sentences_lemmas.length; z++) {
                        sentences_lemmas[z] = window.jstemmer(sentences_lemmas[z]);
                    }
    */

                    var sentences_lemmas_string = sentences_lemmas.join(' ');

                    // Check how many of the nodes are found in This 1 Sentence i

                    for (var j = 0; j < pinnedNodes.length; j++) {

                        // Is the search term cyrillic?
                        var search_cyrillic = pinnedNodes[j].match(/[а-яА-Я]/);

                        // SEARCHMOD
                        // var search_lemma = window.jstemmer(pinnedNodes[j]);

                        var search_lemma = pinnedNodes[j];

                        searchlemmas.push(search_lemma);

                        if (sentences_lemmas_string.toLowerCase().indexOf(search_lemma.toLowerCase()) > -1) {
                            nodesfound = nodesfound + 1;
                        }
                        else if (sentence_cyrillic != null && search_cyrillic != null) {
                            if (sentences_lemmas_string.toLowerCase().indexOf(search_lemma.toLowerCase().slice(0, -1)) > -1) {
                                nodesfound = nodesfound + 1;
                            }
                        }

                    }

                    // At least one node not found? Mark it as non matched

                    if (nodesfound >= pinnedNodes.length) {
                        sentences[i] = sentences[i] + '.';
                    }
                    else {
                        sentences[i] = '<div class="nonmatched-sentence">' + sentences[i] + '.</div>';
                        startmark = startmark - 1;
                    }


                }

                // Make a new text from the filtered sentences
                var newtext = '';

                if (startmark == sentences.length) {
                    newtext = originaltext;
                    // $(this).find('.entry-menu').fadeOut(500);
                    showingsomething = showingsomething + 1;
                }

                else {
                    newtext = originaltext; // sentences.join(' '); if we want to hide non-matched sentences
                    // $(this).find('.entry-menu').fadeIn(500);
                    if (startmark != 0) {
                        showingsomething = showingsomething + 1;
                    }
                }

                if (startmark == 0) {

                    $(this).fadeOut(500);

                    visibleentries = visibleentries - 1;

                    if (visibleentries == 0 && showingsomething == 0) {

                        $('.entry').fadeIn(500);

                        timesfiltered = timesfiltered + 1;

                        // This is if we want to remove the node before the last one.
                        // var posnodes = pinnedNodes.length - timesfiltered - 1;

                        var posnodes = 0;
                        var lastnode = pinnedNodes.length - 1;

                        // Final nodes to search

                        splicedNodes = [];


                        // First all of them

                        for (var k = 0; k < pinnedNodes.length; k++) {
                            splicedNodes[k] = pinnedNodes[k];
                        }

                        // Remove the one we can't find (the very first one of the bunch)

                        splicedNodes.splice(posnodes, 1);

                        // Save that one also into the list of the nodes we removed

                        notfoundNodes.push(pinnedNodes[posnodes]);

                        // This is for alert
                        // var r = confirm('No link between ' + pinnedNodes + '.\nShow entries just with ' + splicedNodes + '?');

                        // This is for plain message
                        // $('#messages').html('No entries contain "' + pinnedNodes.join(' and ') + '".<br>Showing entries that contain "' + splicedNodes.join(' and ') + '" only:<br>&nbsp;');

                        // Get the pinnedNodes back to a good shape
                        pinnedNodes = [];
                        for (var l = 0; l < splicedNodes.length; l++) {
                            pinnedNodes[l] = splicedNodes[l];
                        }

                        // Relaunch the function with the newly cleared list of pinnedNodes

                        filter_statements(pinnedNodes);

                    }

                }
                else {

                    // Populate statement with a new text

                    $(this).children('.entry-text').html(newtext);

                    // $(this).find('.nonmatched-sentence').fadeOut(500); this is only if we want to fade non-matched sentences - see above also


                    // Show tags that are currently used in search

                    var htmlNodes = '<ul class="tags">';

                    for (var x = 0; x < notfoundNodes.length; x++) {
                        htmlNodes = htmlNodes + '<li><a class="notfound" href="#">' + notfoundNodes[x] + '</a></li>';
                    }

                    for (var q = 0; q < pinnedNodes.length; q++) {
                        htmlNodes = htmlNodes + '<li><a href="#">' + pinnedNodes[q] + '</a></li>';
                    }


                    htmlNodes = htmlNodes + '<div class="tagsend"></div></ul>';

                    notfoundNodes = [];

                    $('#messages').html(htmlNodes);


                }


            });

            // Highlight the nodes that were clicked

            $(".entry").removeHighlight();

            for (var i = 0; i < pinnedNodes.length; i++) {
                $(".entry").highlight(pinnedNodes[i]);

            }

            // Show only the clicked nodes and their neighbors in the graph

            filter_graph(pinnedNodes, origin);

            // Add triggers to newly shown Tags elements

            addTagTriggers();

        }

        function addContextTriggers() {

            // TODO Add case for clicking viewAll, so it doesn't reload the page, but simply removes all filters

            // Find @Contexts and make them filter statements when clicked

            var contextsToFilter = [];


            $(".app-context-link").click(function (e) {
                e.preventDefault();
                var that = this;
                setTimeout(function () {
                    var dblclick = parseInt($(that).data('double'), 10);
                    if (dblclick > 0) {
                        $(that).data('double', dblclick - 1);
                    } else {
                        singleClick.call(that, e);
                    }
                }, 300);
            }).dblclick(function (e) {
                $(this).data('double', 2);
                doubleClick.call(this, e);
            });


            // If double click on the menu, open it

            function singleClick(e) {

                window.location = e.target.href;

            }

            // If double click on a link, open it

            $(".app-url-link").on('click tap', function (e) {

                e.stopPropagation();

            });


            // If only one click, filter it

            function doubleClick(e) {

                var triggeredFromStatement = null;

                var addFilter = null;

                var removeFilter = null;

                // Extract filter label
                var filter = $(e.target).text();

                // Remove the first @ in case it's @mentions clicked from the statements
                if (filter.charAt(0) == '@') {
                    filter = filter.substr(1);
                    triggeredFromStatement = 1;
                }

                // Some tricks to make context switch from statements emulate menu items behavior
                if (triggeredFromStatement) {

                    // If the context is clicked inside the statement, we're just dealing with that event, not others
                    e.stopPropagation();

                    $(".menu-item-divided").each(function () {
                        if (S($(this).html()).stripTags().s == filter) {
                            if ($(this).hasClass('pure-menu-selected')) {
                                $(this).removeClass('pure-menu-selected');
                                removeFilter = 1;
                            }
                            else {
                                $(this).addClass('pure-menu-selected');
                                addFilter = 1;
                            }
                        }

                    });
                }

                // Index of that filter in our current contextsToFilter array
                var filterIndex = contextsToFilter.indexOf(filter);

                // Toggle menu highlights
                if ($(this).hasClass('pure-menu-selected') || removeFilter) {


                    // The context is to be removed
                    if (!removeFilter) {
                        $(this).removeClass('pure-menu-selected');
                    }

                    // Does it exist in the list of contexts to filter?
                    if (filterIndex > -1) {
                        contextsToFilter.splice(filterIndex, 1);
                    }

                    //TODO WTF is that?
                    /*  // Let's remove the nodes that belong to the removed context from the contextNodes
                      contextNodeID[to_remove_clean].forEach(function(element){
                          var index = $.inArray(element, contextNodes);
                          if (index>=0) contextNodes.splice(index, 1);
                      });*/


                    // Create context query for jQuery
                    var contextstring = '';

                    if (contextsToFilter.length >= 0) {
                        contextstring += ".entry:contains('@" + contextsToFilter[0] + "')";

                        for (var l = 1; l < contextsToFilter.length; ++l) {
                            contextstring += ", .entry:contains('@" + contextsToFilter[l] + "')";
                        }

                        $('.entry').addClass('hidden');
                        $(contextstring).removeClass('hidden');

                    }
                    else {
                        $('.entry').removeClass('hidden');
                    }


                    if (contextsToFilter.length < 1 && !$('#listall').hasClass('pure-menu-selected') && !(current_context)) {
                        $('#listall').addClass('pure-menu-selected');
                    }

                }
                else {
                    if (!addFilter) {
                        $(this).addClass('pure-menu-selected');
                    }

                    // Add this context to a list of contextToFilter
                    if (filterIndex < 0) {
                        contextsToFilter.push(filter);
                    }

                    // Show only those that have the context

                    var contextstring = '';
                    if (contextsToFilter.length >= 0) {
                        contextstring += ".entry:contains('@" + contextsToFilter[0] + "')";

                        for (var l = 1; l < contextsToFilter.length; ++l) {
                            contextstring += ", .entry:contains('@" + contextsToFilter[l] + "')";
                        }

                        $('.entry').addClass('hidden');
                        $(contextstring).removeClass('hidden');

                    }
                    else {
                        $('.entry').removeClass('hidden');
                    }


                    if ($('#listall').hasClass('pure-menu-selected')) {
                        $('#listall').removeClass('pure-menu-selected');
                    }


                }

                console.log(contextsToFilter);

                // Add contexts into the submission form
                document.getElementById('selectedContexts').value = contextsToFilter.join(',');

                console.log(document.getElementById('selectedContexts').value);

                // Add some remove @context functionality
                renderGraph(contextsToFilter);

            }

        }


        // Remove context filters function - launched only when a context is clicked

        function renderGraph(contextsToFilter) {

            // Creating the context index
            var nodesToKeep = [];

            var keepNodes = [];

            var keepEdges = [];

            // First, let's reiterate the graph and make a list of nodes and edges to keep

            if (contextsToFilter.length > 0) {

                sigma.instances(0).graph.edges().forEach(function (e) {

                    // Reiterating through edges, leaving only the nodes that appear in at least one filtered context

                    contextsToFilter.forEach(function (element) {

                        if (contextNodeID[element].indexOf(e.source) > -1) {
                            keepNodes.push(e.source);
                        }

                        if (contextNodeID[element].indexOf(e.target) > -1) {
                            keepNodes.push(e.target);
                        }

                    });

                    // Keep edges that are in at least one of the filtered contexts

                    if (contextsToFilter.indexOf(e.edge_context) > -1) {
                        keepEdges.push(e.id);
                    }


                });
            }

            // Uniqualize to avoid duplicates

            keepNodes = $.unique(keepNodes);
            keepEdges = $.unique(keepEdges);

            // Then let's reiterate the graph edges and only show nodes that belong to the contexts created

            sigma.instances(0).graph.edges().forEach(function (e) {

                if (contextsToFilter.length == 0) {
                    // Show the edge if there's no contexts at all
                    e.color = e.originalColor;
                }

                else if (keepEdges.indexOf(e.id) > -1) {
                    // The edge is in the list to keep => show it normal color
                    e.color = e.originalColor;

                    // The source of the edge is in the list to keep, so we will keep it.
                    if (keepNodes.indexOf(e.source) > -1) {
                        nodesToKeep.push(e.source);
                    }
                    // The target of the edge is in the list to keep, so we will keep it also.
                    if (keepNodes.indexOf(e.target) > -1) {
                        nodesToKeep.push(e.target);
                    }
                    // PS We only do this check for the nodes that belong to the edges that we keep
                }
                else {
                    // Otherwise (the edge IS in the list for removal), so we color the edge invisible
                    e.color = '#ddd';
                }


            });


            // Ensure no duplicates
            nodesToKeep = $.unique(nodesToKeep);

            // Now that we know which nodes to keep, let's reiterate through them all

            sigma.instances(0).graph.nodes().forEach(function (n) {

                // Is there no contexts at all? Show the node.
                if (contextsToFilter.length == 0) {
                    n.color = n.originalColor;
                    n.label = n.originalLabel;
                }

                // The node is not in the list to keep? Hide it!
                else if (nodesToKeep.indexOf(n.id) < 0) {
                    n.color = '#ddd';
                    n.label = '';
                }

                // Looks like there is a filtering context function AND the node is in the keep list, so make it show!
                else {
                    n.color = n.originalColor;
                    n.label = n.originalLabel;
                }
            });


            // Refresh the graph (we do it through instances(0) as we're a bit outside of Sigma now)
            sigma.instances(0).refresh();


        }


        // Populate context menu

        function populateContextMenu(contextNames, nodeNames) {

            var switch_field = '';

            var context_filters = '';

            var currentContextURL = '';

            <% if (perceivername) { %>

            currentContextURL = '<li id="listall" class="menu-item-divided pure-menu-selected"><a href="/<%= perceivername %>">all sets</a></li>';

            <% } else { %>

            currentContextURL = '<li id="listall" class="menu-item-divided pure-menu-selected"><a href="/<%= user.name %>/edit">all sets</a></li>';

            <% } %>

            var addNewContext = '';

            var auxLinks = '';

            // The graph exists already?
            if (typeof contextNames[0] !== 'undefined' && contextNames[0] !== null) {
                contextNames.forEach(function (n) {
                    if (n == current_context) {
                        // for the menu
                        <% if (perceivername) { %>
                        context_filters += '<li class="app-context-link menu-item-divided pure-menu-selected"><a href="/<%= perceivername %>/' + n + '">' + n + '</a></li>';
                        currentContextURL = '<li id="listall" class="menu-item-divided"><a href="/<%= perceivername %>">all sets</a></li>';
                        <% } else { %>
                        context_filters += '<li class="app-context-link menu-item-divided pure-menu-selected"><a href="/<%= user.name %>/' + n + '/edit">' + n + '</a></li>';
                        currentContextURL = '<li id="listall" class="menu-item-divided"><a href="/<%= user.name %>/edit">all sets</a></li>';
                        <% } %>

                    }
                    else {
                        // for the menu
                        <% if (perceivername) { %>
                        context_filters += '<li class="app-context-link menu-item-divided "><a href="/<%= perceivername %>/' + n + '">' + n + '</a></li>';
                        <% } else { %>
                        context_filters += '<li class="app-context-link menu-item-divided "><a href="/<%= user.name %>/' + n + '/edit">' + n + '</a></li>';

                        <% } %>

                        // for the statement add
                    }
                });
            }
            // No graph, so show private
            else {
                context_filters += '<li class="app-context-link menu-item-divided"><a href="/<%= perceivername %>/private/edit">private</a></li>';
            }

            <% if (!perceivername) { %>
            addNewContext = '<li id="addNewContext" class="menu-item-divided"><a id="addcontextbutton" href="javascript:">+</a>&nbsp;<form action="/post" method="GET" class="pure-form" id="addcontextinput"><input type="text" id="addcontextname" size="7" class="pure-input"></form></li><li class="menu-item-divided">&nbsp;<a href="javascript:"></a></li>';
            <% } else { %>
            addNewContext = '<li class="menu-item-divided">&nbsp;<a href="javascript:"></a></li>';

            <% } %>


            // We are viewing the user's public page?

            <% if ((perceivername)) { %>

            // So we know whose statements we see, but is it the same as the user who's viewing them?
            <% if (perceivername == receivername) { %>

            <% if (context) { %>
            switch_field = '<li class="menu-item-small"><a href="/<%= perceivername %>/<%= context %>/edit">go to private view</a></li>';
            <% } else { %>
            switch_field = '<li class="menu-item-small"><a href="/<%= perceivername %>/edit">go to private view</a></li>';
            <% } %>

            // So we know whose statements we're going to view, but the user is not the same as the one who made them.
            <% } else { %>



            <% } %>

            // We are viewing the user's private page

            <% } else { %>

            <% if (context) { %>

            switch_field = '<li class="menu-item-small"><a href="/<%= user.name %>/<% context %>">go to public view</a></li>';

            <% } else { %>

            switch_field = '<li class="menu-item-small"><a href="/<%= user.name %>">go to public view</a></li>';

            <% } %>


            <% } %>


            <% if (perceivername) { %>

            <% if (perceivername == receivername) { %>

            auxLinks = '<br>' +
                '<li class="menu-item-small"><a href="/<%= perceivername %>/edit">back to private view</a></li>' +
                '<li class="menu-item-small">&nbsp;</li>' +
                '<li class="menu-item-small"><a href="/logout">logout</a></li>' +
                '<li class="menu-item-small"><a href="/settings">settings</a></li>' +
                '<li class="menu-item-small"><a href="/import">import</a></li>' +
                '<li class="menu-item-small"><a href="/api/public/nodes/<%= perceivername %>/<%= context %>?gexf=1" target="_blank">export</a></li>' +
                '<li class="menu-item-small"><a href="http://noduslabs.com/infranodus/" target="_blank">about</a></li>' +
                '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';


            <% } else if (receivername) { %>

            auxLinks = '<br>' +
                '<li class="menu-item-small"><a href="/<%= receivername %>/edit">back to <%= receivername %></a></li>' +
                '<li class="menu-item-small">&nbsp;</li>' +
                '<li class="menu-item-small"><a href="/">home page</a></li>' +
                '<li class="menu-item-small">&nbsp;</li>' +
                '<li class="menu-item-small"><a href="/settings">settings</a></li>' +
                '<li class="menu-item-small"><a href="/import">import</a></li>' +
                '<li class="menu-item-small"><a href="/api/user/nodes/<%= context %>?gexf=1" target="_blank">export</a></li>' +
                '<li class="menu-item-small"><a href="http://noduslabs.com/infranodus/" target="_blank">about</a></li>' +
                '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';


            <% } else { %>

            auxLinks = '<br>' +
                '<li class="menu-item-small"><a href="/">home page</a></li>' +
                '<li class="menu-item-small">&nbsp;</li>' +
                '<li class="menu-item-small"><a href="/login">login</a></li>' +
                '<li class="menu-item-small"><a href="/signup">signup</a></li>' +
                '<li class="menu-item-small">&nbsp;</li>' +
                '<li class="menu-item-small"><a href="/api/public/nodes/<%= perceivername %>/<%= context %>?gexf=1" target="_blank">export</a></li>' +
                '<li class="menu-item-small"><a href="http://noduslabs.com/infranodus/" target="_blank">about</a></li>' +
                '<li class="menu-item-small"><a href="/#features">demo</a></li>' +
                '<li class="menu-item-small"><a href="/#usecases">case studies</a></li>' +
                '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';

            <% } %>

            <% } else { %>

            auxLinks = '<br>' +
                '<li class="menu-item-small"><a href="/logout">logout</a></li>' +
                '<li class="menu-item-small"><a href="/settings">settings</a></li>' +
                '<li class="menu-item-small"><a href="/import">import</a></li>' +
                '<li class="menu-item-small"><a href="/api/user/nodes/<%= context %>?gexf=1" target="_blank">export</a></li>' +
                '<li class="menu-item-small"><a href="http://noduslabs.com/cases/infranodus-the-network-thinking-app/" target="_blank">demo</a></li>' +
                '<li class="menu-item-small"><a href="http://noduslabs.com/tag/infranodus/" target="_blank">case studies</a></li>' +
                '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';

            <% } %>

            document.getElementById('contexts').innerHTML = switch_field +
                currentContextURL +
                context_filters +
                addNewContext +
                auxLinks;


            // Select range in textarea function

            $.fn.selectRange = function (start, end) {
                return this.each(function () {
                    if (this.setSelectionRange) {
                        this.focus();
                        this.setSelectionRange(start, end);
                    } else if (this.createTextRange) {
                        var range = this.createTextRange();
                        range.collapse(true);
                        range.moveEnd('character', end);
                        range.moveStart('character', start);
                        range.select();
                    }
                });
            };

            // When add new context is clicked, add it into textarea and select it

            $("#addNewContext").on('tap', function (e) {

                $("#addcontextinput").css("visibility", "visible");
                $("#addcontextname").focus();


            });

            <% if (!perceivername) { %>
            $('#addcontextinput').submit(function (e) {
                e.preventDefault(); // to stop the form from submitting
                if ($('#addcontextname').val().length > 0) {
                    var contextredirect = $('#addcontextname').val();
                    contextredirect = contextredirect.replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()]/g, "");
                    contextredirect = contextredirect.replace(/[^\w]/gi, '');
                    window.location.href = "/<%= user.name %>/" + contextredirect + '/edit';
                }

            });
            <% } %>

            // Now time to trigger the actions we want to have when user clicks on the contexts
            addContextTriggers();

            // Initialize autofill for hashtags and contexts
            autofill(nodeNames, contextNames);


        }

        function search_graph() {

            // Autocomplete for search input
            $("#search").autocomplete({
                source: nodeNames,
                minLength: 1,
                delay: 500,
                messages: {
                    noResults: '',
                    results: function () {
                    }
                },
                select: function (event, ui) {

                    var filter = ui.item.value;


                }

            });

            $("#searchform").submit(function (event) {

                event.preventDefault();

                // What are we searching?
                var searchPhrase = $('#search').val();

                if (searchPhrase.length > 1) {

                    // Clean up the search string
                    searchPhrase = searchPhrase.replace(/\s+/g, ' ').trim();

                    // Separate terms into array
                    var searchArray = searchPhrase.toLowerCase().split(" ");

                    var searchPhraseLemmas = [];


                    for (var j = 0; j < searchArray.length; j++) {

                        // Is the search term cyrillic?
                        var search_cyrillic = searchArray[j].match(/[а-яА-Я]/);

                        // SEARCHMOD
                        // var search_lemma = window.jstemmer(searchArray[j]);

                        var search_lemma = searchArray[j];

                        searchPhraseLemmas.push(search_lemma);

                    }

                    for (var k = 0; k < searchPhraseLemmas.length; k++) {
                        if (pinnedNodes.indexOf(searchPhraseLemmas[k]) < 0) {
                            pinnedNodes.push(searchPhraseLemmas[k]);
                        }
                    }

                    filter_statements(pinnedNodes, "search");

                }


            });
        }


        function filter_graph(pins, origin) {


            var toKeep = [];

            var toKeepMap = [];


            // Debug: show which nodes are clicked

            console.log(pins);

            // Are any nodes at all selected on the graph?

            if (pins.length > 0) {


                // Reiterate for each pinned node

                for (var i = 0; i < pins.length; i++) {

                    // Now we reiterate through every node in the graph

                    sigma.instances(0).graph.nodes().filter(function (n) {

                        var pinSearch = '';

                        // Lemmataze search query if we're coming from search box

                        // SEARCHMOD
                        /* if (origin == 'search') {

                             var nodeLemma = window.jstemmer(n.originalLabel);


                             if (nodeLemma.length > 0) {
                                 pinSearch = nodeLemma;
                             }
                             else {
                                 pinSearch = n.originalLabel;
                             }
                         }

                         // This means the user clicked on the tag or on the graph, so we use that exact parameter to search

                         else {
                             pinSearch = n.originalLabel;
                         }*/

                        pinSearch = n.originalLabel;

                        // Is the current node of the graph one of the ones that was clicked before?

                        if (pins[i] == pinSearch) {



                            // The ID of the current node is...
                            var nodeId = n.id;

                            // Its neighbors are...
                            var nnodes = sigma.instances(0).graph.neighbors(nodeId);

                            var nnodesArray = []

                            // We create an array from neighbors that looks like toKeep one

                            for (key in nnodes) {
                                nnodesArray.push(nnodes[key]);
                            }

                            // If that's not the first iteration, we only keep intersection of both

                            if (i > 0) {
                                toKeep = _.intersection(toKeep, nnodesArray);
                            }
                            else {
                                toKeep = nnodesArray;
                            }

                            // add the node itself to keep
                            toKeep.push(n);


                        }

                    });

                }

                // Make array of nodes to keep unique to avoid duplicates

                toKeep = _.uniq(toKeep);

                console.log(toKeep);

                // Now convert this to an array that will be understood by the functions below

                for (key in toKeep) {
                    toKeepMap[toKeep[key].id] = toKeep[key];
                }


                // For each node in the graph

                sigma.instances(0).graph.nodes().forEach(function (n) {

                    if (toKeepMap[n.id]) {

                        var pinSearch = '';

                        // Lemmataze search query if we're coming from search box
                        // SEARCHMOD
                        /* if (origin == 'search') {
                             var nodeLemma = window.jstemmer(n.originalLabel);


                             if (nodeLemma.length > 0) {
                                 pinSearch = nodeLemma;
                             }
                             else {
                                 pinSearch = n.originalLabel;
                             }
                         }

                         // This means the user clicked on the tag or on the graph, so we use that exact parameter to search

                         else {
                             pinSearch = n.originalLabel;
                         }*/

                        pinSearch = n.originalLabel;


                        if (pins.indexOf(pinSearch) > -1) {
                            n.color = '#0089e0';

                        }
                        else {
                            n.color = n.originalColor;

                        }
                        n.label = n.originalLabel;

                    }
                    else {
                        n.color = '#ddd';
                        n.label = '';
                    }
                });

                sigma.instances(0).graph.edges().forEach(function (e) {
                    if (toKeepMap[e.source] && toKeepMap[e.target]) {
                        e.color = e.originalColor;
                    }
                    else {
                        e.color = '#ddd';
                    }
                });


            }

            // No nodes are selected (or all are deselected) - show the whole graph

            else {

                sigma.instances(0).graph.nodes().forEach(function (n) {


                    n.color = n.originalColor;
                    n.label = n.originalLabel;


                });

                sigma.instances(0).graph.edges().forEach(function (e) {

                    e.color = e.originalColor;

                });


                // We show the whole graph above so scroll down to all the statements
                $("#entries").animate({scrollTop: $('#entries')[0].scrollHeight}, 1000);


            }

            // Since the data has been modified, we need to
            // call the refresh method to make the colors
            // update effective.

            sigma.instances(0).refresh();


        }

        // Autofill initialized only after Sigma above loaded and populated all the nodes

        function autofill(nodeNames, contextNames) {

            // console.log(nodeNames);

            $('#statement').textcomplete([
                { // hashtags-concepts
                    words: nodeNames,
                    match: /\B#(\w*)$/,
                    search: function (term, callback) {
                        callback($.map(this.words, function (word) {
                            return word.indexOf(term) === 0 ? word : null;
                        }));
                    },
                    index: 1,
                    replace: function (word) {

                        return '#' + word + ' ';

                    }
                },
                { // html
                    mentions: contextNames,
                    match: /\B@(\w*)$/,
                    search: function (term, callback) {
                        callback($.map(this.mentions, function (mention) {
                            return mention.indexOf(term) === 0 ? mention : null;
                        }));
                    },
                    index: 1,
                    replace: function (mention) {
                        return '@' + mention + ' ';
                    }
                },
                { // hashtags-concepts
                    words: nodeNames,
                    match: /\b(\w{2,})$/,
                    search: function (term, callback) {
                        callback($.map(this.words, function (word) {
                            return word.indexOf(term) === 0 ? word : null;
                        }));
                    },
                    index: 1,
                    replace: function (word) {

                        return word + ' ';

                    }
                }

            ]);


            $('#addcontext').textcomplete([
                { // html
                    mentions: contextNames,
                    match: /\b(\w{2,})$/,
                    search: function (term, callback) {
                        callback($.map(this.mentions, function (mention) {
                            return mention.indexOf(term) === 0 ? mention : null;
                        }));
                    },
                    index: 1,
                    replace: function (mention) {
                        window.open("?addcontext=" + mention, "_self");
                        return '@' + mention + '';
                    }
                }
            ]);
        }

        function addTagTriggers() {


            $(".tags").on('click', function (e) {

                e.preventDefault();

                var remove_node = e.target.innerText;

                var pinnedIndex = pinnedNodes.indexOf(remove_node);


                if (pinnedIndex > -1) {

                    pinnedNodes.splice(pinnedIndex, 1);

                    notfoundNodes.push(remove_node);

                }

                if (splicedNodes.length > 1) {
                    pinnedNodes = [];
                    for (var p = 0; p < splicedNodes.length; p++) {
                        pinnedNodes[p] = splicedNodes[p];
                    }
                }
                else if (splicedNodes.length == 1) {
                    pinnedNodes = [];
                    pinnedNodes[0] = splicedNodes[0];
                    splicedNodes = [];
                }

                // console.log("node clicked, now will filter for nodes " + pinnedNodes);

                $('.entry').fadeIn(400);

                filter_statements(pinnedNodes);


            });

        }

        // Replace hashtags function

        function replaceHashtags(hash) {
            var replacementString = $.trim(hash);
            return ' <a href="' + forwardTo + replacementString.substr(1) + '" class="app-concept-link" target="_blank">' + replacementString + '</a>';
        }


        var hashRegex = /(?:\s|^)(?:#(?!\d+(?:\s|$)))(\w+)(?=\s|$)/gi;

        if (link_hashtags) {
            $(".entry").each(function () {
                // Retrieve the statement text from the entry, clean from html
                var originale = $(this).children('.entry-text').html();
                // Replace with hashtags
                $(this).children('.entry-text').html(originale.replace(/#(\w+)/g, " <a href='" + forwardTo + "$1' class='app-concept-link' target='_blank'>$&</a>"));

            });
        }


        // LiveChat functionality

        if (window.addEventListener) {
            window.addEventListener("message", function (event) {
                if (event.data != null || event.data != "") {

                    var message_array = event.data.split("%3B");

                    if (message_array[0] == 'message_received' || message_array[0] == 'message_sent') {

                        var message_clean = decodeURIComponent(message_array[1].replace(/%25/g, '%'));

                        var urlRegex = /((\#\#\#))/ig;

                        var infraExtract = urlRegex.exec(message_clean);

                        // message_clean !== 'So, shall we begin our conversation?' && message_clean !== 'So, shall we continue our conversation?' &&

                        if (infraExtract == null && current_context.substr(0, 1) == '_') {
                            if (message_clean.length > 4) {
                                $('#statement').text(message_clean);
                                $('#submitbutton').trigger('click');
                            }
                        }

                    }


                }
            });
        }
        else {
            window.attachEvent("onmessage", function (event) {
                if (event.data != null || event.data != "") {
                }
            });
        }


    })();
</script>

<% include statsbelow %>
</body>
</html>